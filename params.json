{"name":"JRoutine","tagline":"Parallel programming on the go","body":"##Overview\r\n\r\nInspired by the Go routines, this library provides a powerful, flexible, yet familiar concurrency framework, designed to make multi-threads programming simple and funny.\r\n\r\nThe main paradigm is based on routines and channels. A routine is the container in which a piece of code is executed asynchronously. It takes care of the synchronization and manages the invocation lifecycle. The channels are means of communication between the routine and the outside world.\r\n\r\nA routine can be invoked in a synchronous, asynchronous and parallel way. The main difference between the asynchronous and the parallel invocation is that, in the former, all the input data are processed by the same invocation instance, while, in the latter, each input item is (potentially) processed by a different one. For example, if the sum of the inputs has to be computed by the routine, an asynchronous invocation is the way to go, while, when the routine is used to compute, for instance, the square of a number, all the inputs can be safely processed in parallel.\r\n\r\nAfter the invocation, the routine returns an input channel which is used to pass the input parameters. Input data can be passed in bulk or streamed, delayed or fetched asynchronously from another channel. When done with the input, the channel is closed and returns an output channel used to read the invocation results.\r\n\r\nThe main way to define a routine is to implement an invocation object. Though, the library provides several other ways (always backed by invocations) to call any method of any object (even defined in third party source code) asynchronously.\r\n\r\n##It's reactive!\r\n\r\nThe library adheres to [The Reactive Manifesto][17]. It's responsive, resilient, elastic and \"message driven\".\r\n\r\nIt's responsive because commands are enqueued to be executed asynchronously so to never block the calling thread. Computation of asynchronous invocations happens only in response of inputs and resources are freed as soon as the input is consumed. Resources are allocated only when needed, and reused when possible.\r\nIt's resilient because errors are gracefully handled and notified through the proper methods implemented by the specific invocation classes.\r\nIt's elastic because the needed number of threads is allocated in response to higher loads.\r\nIt's \"message driven\" because both ouputs and errors are dispatched along the chain of invocations.\r\n\r\n##Why not RxJava?\r\n\r\nAmong the many open source libraries, [RxJava][7] is one of the preferred choices when it comes to handle background tasks.\r\nAlthough [Reactive Extensions][8] is a great tool for managing events and composing event listeners, it has not been clearly designed with parallel programming in mind.\r\nIn fact, RxJava shows a few limits in this respect.\r\nThe framework has once been compared, with a fitting example, to a line of domino pieces: once the first tile falls down, all the others are to follow, and there is no way to stop them other than to cut the line.\r\nEach time a background operation is required, the whole chain of observables/subscribers must be rebuilt from scratch, the chained functions are called recursively and many objects are created in the while.\r\nWhile such design works great for common events, it does not adapt so well to background tasks.\r\nAfter all, a network request does not really fit in the definition of \"event\".\r\n\r\nRxJava is still one of the best library for handling events, though, something specifically designed is needed to make parallel programming easily accessible and manageable.\r\n\r\n##Why JRoutine?\r\n\r\nThe JRoutine library is based on a single paradigm, at the same time simple, but flexible and powerful enough to provide all the features needed to perform, manage and combine asynchronous tasks in any environment and on any platform.\r\nThis paradigm is nothing but what any developer is already familiar to, that is, a function call.\r\n\r\nWhat the library has to offer is:\r\n\r\n* ***Flat learning curve***: a single paradigm to make everything: invoke the routine, pass the inputs, read the results\r\n* ***Extreme configurability***: each routine instance may have its own set of configurations, and its own source of concurrency\r\n* ***Ease of integration***: no need to modify existing code to make a method asynchronous\r\n* ***Memory optimization***: maximum number of invocations running and retained in the instance pool, and maximum number of data passed through the channels, are just some of the parameters that can be tuned to lower memory consumption\r\n* ***Data streaming***: not all the inputs might be known at the time of invocation, and outputs might need to be fetched at specific points of the code execution\r\n* ***Real processing abort***: invocations can be interrupted at any moment between two data are passed to the input or output channels, thus achieving real abortion of the processing and not a mere removal of a listener\r\n* ***Non-recursive calls***: even during synchronous invocations, recursion is broken up in a sequential sequence of operations\r\n* ***Automatic code generation***: as an alternative to reflection, existing methods can be made asynchronous through annotation pre-processing and compile-time code generation\r\n* ***Nice handling of Android configuration changes***: the same paradigm is applied on the Android platform so to support background tasks surviving changes in the configuration of Activities or Fragments\r\n\r\nAnd more:\r\n\r\n* ***< 170KB Jar***\r\n* ***Java 5+**** ***and Android 1.6+***\r\n* ***@Nullable and @Nonnull annotations***\r\n\r\n(*) for older Java versions please have a look at [Retrotranslator][16].\r\n\r\n##Why not JRoutine?\r\n\r\nThe JRoutine library is designed for parallel programming and nothing else. It's no golden hammer and does not pretend to.\r\nIf you need event handling, please use [RxJava][7], it's one of the best library out there. If you need distributed scalable computing, consider using [Akka][9].\r\nFor anything else [GitHub][10] is a great source of inspiration.\r\n\r\n##Usage examples\r\n\r\nPlease have a look at the dedicated [wiki page][5].\r\n\r\n##Documentation\r\n\r\nComplete Javadoc with insights and examples is available for:\r\n\r\n* [JRoutine][13]\r\n* [JRoutine-Android][14]\r\n\r\nThe project contains an additional sample module showing how to implement a file downloader with just 4 classes.\r\n\r\n##Further development\r\n\r\nFeel free to contribute with your own [Runner][15] so to support more platforms other than Android.\r\n\r\n##Build instructions\r\n\r\nPlease refer to the dedicated [wiki page][4].\r\n\r\n##Dependencies\r\n\r\n####Runtime dependencies\r\n\r\n- None\r\n\r\n####Compile dependencies\r\n\r\n- [FindBugs][11] annotations ([Lesser GNU Public License][3])\r\n- Android SDK ([Terms and Condition][1])\r\n- Android Support Library ([Apache License v2.0][2])\r\n\r\n####Test dependencies\r\n\r\n- JUnit ([Eclipse Public License v1.0][6])\r\n- [AssertJ][12] ([Apache License v2.0][2])\r\n\r\n##License\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;[http://www.apache.org/licenses/LICENSE-2.0][2]\r\n\r\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\r\n\r\n**IT'S OPEN DUDE!**\r\n\r\n\r\n[1]:http://developer.android.com/sdk/terms.html\r\n[2]:http://www.apache.org/licenses/LICENSE-2.0\r\n[3]:http://www.gnu.org/licenses/lgpl.html\r\n[4]:https://github.com/davide-maestroni/jroutine/wiki/Build-Instructions\r\n[5]:https://github.com/davide-maestroni/jroutine/wiki/Usage-Examples\r\n[6]:https://www.eclipse.org/legal/epl-v10.html\r\n[7]:https://github.com/ReactiveX/RxJava\r\n[8]:http://reactivex.io/\r\n[9]:http://akka.io/\r\n[10]:https://github.com/\r\n[11]:http://findbugs.sourceforge.net/\r\n[12]:http://joel-costigliola.github.io/assertj/\r\n[13]:http://davide-maestroni.github.io/jroutine/docs/jroutine\r\n[14]:http://davide-maestroni.github.io/jroutine/docs/android\r\n[15]:http://davide-maestroni.github.io/jroutine/docs/jroutine/com/gh/bmd/jrt/runner/Runner.html\r\n[16]:http://retrotranslator.sourceforge.net/\r\n[17]:http://www.reactivemanifesto.org/\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}