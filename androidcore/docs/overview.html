<!--
  ~ Copyright 2016 Davide Maestroni
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<html>
<head>
    <title>jroutine-android</title>
</head>
<body>
<a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a>
<p>
    Android platform customization of the <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/core" target="_blank">jroutine-core</a> library.
</p>
<p>
    The code below shows how it is possible to load an image from the network in a background thread, by letting the library automatically handle any change in the configuration.<br>
    Note that the very same examples can be re-written using JRoutineLoaderCompat class and a FragmentActivity.
</p>
<b>Example 1:</b> simple approach.
<p>
    Note that this approach is fairly naive, since it lets the framework retain the instance of the downloaded bitmap.<br>
    A smarter implementation would involve the use of a dedicated cache.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoader.with(loaderFrom(this))
                              .on(factoryOf(LoadBitmap.class))
                              .loaderConfiguration()
                              .withCacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                              .apply()
                              .asyncCall(URI.create(IMAGE_URI))
                              .bind(new TemplateOutputConsumer&lt;Bitmap&gt;() {

                                  &commat;Override
                                  public void onError(&commat;NotNull final RoutineException error) {
                                      final Throwable cause = error.getCause();
                                      Toast.makeText(MainTestActivity.this, (cause != null) ?
                                              cause.getMessage() : "Cannot load image",
                                              Toast.LENGTH_LONG).show();
                                  }

                                  &commat;Override
                                  public void onOutput(final Bitmap bitmap) {
                                      imageView.setImageBitmap(bitmap);
                                  }
                              });
            }

            public static class LoadBitmap extends TemplateContextInvocation&lt;URI, Bitmap&gt; {

                &commat;Override
                public void onInput(final URI uri, &commat;NotNull final Channel&lt;Bitmap, ?&gt; result) throws
                        Exception {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap != null) {
                            result.pass(bitmap);

                        } else {
                            result.abort();
                        }

                    } finally {
                        inputStream.close();
                    }
                }
            }
        }
    </code>
</pre>
<b>Example 2:</b> load in a service.
<p>
    The above example can be slightly modified to make the real loading happen in a dedicated service.<br>
    Note that the service might even run in a separate process, since the Bitmap class implements the Parcelable interface. However, keep in mind that, depending on the specific image size, the amount of serialized data might exceed the parcel limits.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoader.with(loaderFrom(this))
                              .on(factoryOf(LoadBitmapFromService.class))
                              .loaderConfiguration()
                              .withCacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                              .apply()
                              .asyncCall(URI.create(IMAGE_URI))
                              .bind(new TemplateOutputConsumer&lt;Bitmap&gt;() {

                                  &commat;Override
                                  public void onError(&commat;NotNull final RoutineException error) {
                                      final Throwable cause = error.getCause();
                                      Toast.makeText(MainTestActivity.this, (cause != null) ?
                                              cause.getMessage() : "Cannot load image",
                                              Toast.LENGTH_LONG).show();
                                  }

                                  &commat;Override
                                  public void onOutput(final Bitmap bitmap) {
                                      imageView.setImageBitmap(bitmap);
                                  }
                              });
            }

            public static class LoadBitmap extends TemplateContextInvocation&lt;URI, Bitmap&gt; {

                &commat;Override
                public void onInput(final URI uri, &commat;NotNull final Channel&lt;Bitmap, ?&gt; result) throws
                        Exception {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap != null) {
                            result.pass(bitmap);

                        } else {
                            result.abort();
                        }

                    } finally {
                       inputStream.close();
                    }
                }
            }

            public static class LoadBitmapFromService extends TemplateContextInvocation&lt;URI, Bitmap&gt; {

                private Routine&lt;URI, Bitmap&gt; mRoutine;

                &commat;Override
                public void onContext(&commat;NotNull final Context context) {
                    super.onContext(context);
                    mRoutine = JRoutineService.with(serviceFrom(context))
                                              .on(TargetInvocationFactory.factoryOf(LoadBitmap.class))
                                              .buildRoutine();
                }

                &commat;Override
                public void onInput(final URI uri, &commat;NotNull final Channel&lt;Bitmap, ?&gt; result) {
                    result.pass(mRoutine.asyncCall(uri));
                }
            }
        }
    </code>
</pre>
</body>
</html>