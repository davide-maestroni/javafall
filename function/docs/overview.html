<!--
  ~ Copyright 2016 Davide Maestroni
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<html>
<head>
    <title>jroutine-function</title>
</head>
<body>
<a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the
    go.</a>
<h1>Overview</h1>
<p>
    Java functional programming based on the <a
        href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/core" target="_blank">jroutine-core</a>
    library.
</p>
<p>
    This module provides classes back-porting Java 8 functional interfaces. Moreover, utility
    classes allow the creation of invocation factories based on implementations of such interfaces.
</p>
<h2>Main concepts</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/Action.html">Action</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/BiConsumer.html">BiConsumer</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/BiFunction.html">BiFunction</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/Consumer.html">Consumer</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/Function.html">Function</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/Predicate.html">Predicate</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/Supplier.html">Supplier</a>
        <p>
            Functional interfaces.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/ActionDecorator.html">ActionDecorator</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/BiConsumerDecorator.html">BiConsumerDecorator</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/BiFunctionDecorator.html">BiFunctionDecorator</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/ConsumerDecorator.html">ConsumerDecorator</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/FunctionDecorator.html">FunctionDecorator</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/PredicateDecorator.html">PredicateDecorator</a>,
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/util/SupplierDecorator.html">SupplierDecorator</a>
        <p>
            Each functional interface has a corresponding decorator class enabling comparison and
            composition.
        </p>
    </li>
</ul>
<h2>Main classes</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/JRoutineFunction.html">JRoutineFunction</a>
        <p>
            Utility class acting as a factory of functional builders of routines and channel
            consumers.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/function/com/github/dm/jrt/function/Functions.html">Functions</a>
        <p>
            This utility class exposes several methods to decorate functional interfaces so to add
            composition and comparison features.
            Moreover, it provides methods to create invocation factories starting from one of the
            functional interfaces defined in the package.
        </p>
    </li>
</ul>
<h2>Dependencies</h2>
<p>
    Below a full list of the included modules:
</p>
<ul>
    <li><a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/core" target="_blank">jroutine-core</a> &mdash;
        core routine and channel classes
    </li>
</ul>
<h2>Usage examples</h2>
<p>
    The code below shows how it is possible to implement the computation of the root mean square of
    some input data, by distributing it in a number of background threads.
</p>
<b>Example 1:</b> via routine builders.
<p>
    The lambda notation used in the example is just for demonstration purpose. In order to compile
    with Java 7 or below, explicit object creation must be employed.<br>
    In fact, the interfaces defined in the "util" package are conceptually <a
        href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html"
        target="_blank">functional interfaces</a>.
</p>
<pre>
    <code>
        public class Main {

            public static void main(final String[] args) {
                final Routine&lt;String, Integer&gt; parseRoutine =
                        JRoutineFunction.&lt;String, Integer&gt;stateless()
                                        .onNextOutput(Integer::parseInt)
                                        .invocationConfiguration()
                                        .withInvocationMode(InvocationMode.PARALLEL)
                                        .apply()
                                        .buildRoutine();
                final Routine&lt;Integer, Integer&gt; squareRoutine =
                        JRoutineFunction.&lt;Integer, Integer&gt;stateless()
                                        .onNextOutput(integer -&gt; {
                                            final int input = integer;
                                            return (input * input);
                                        })
                                        .invocationConfiguration()
                                        .withInvocationMode(InvocationMode.PARALLEL)
                                        .apply()
                                        .buildRoutine();
                final Routine&lt;Integer, Double&gt; meanRoutine =
                        JRoutineFunction.&lt;Integer, Double, MeanState&gt;stateful()
                                        .onCreate(MeanState::new)
                                        .onNextConsume(MeanState::add)
                                        .onCompleteOutput(MeanState::mean)
                                        .buildRoutine();
                final Double rms =
                        meanRoutine.invoke()
                                   .pass(squareRoutine.invoke()
                                                      .pass(parseRoutine.invoke().pass(args).close())
                                                      .close())
                                   .close()
                                   .in(seconds(3))
                                   .next();
                System.out.println(rms);
                System.exit(0);
            }

            private static class MeanState {

                private int sum;

                private int count;

                private void add(final int i) {
                    sum += i;
                    ++count;
                }

                private double mean() {
                    return (count > 0) ? Math.sqrt((double) sum / count) : 0;
                }
            }
        }
    </code>
</pre>
</body>
</html>