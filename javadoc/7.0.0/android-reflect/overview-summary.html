<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_77) on Fri Feb 10 21:34:20 CET 2017 -->
<title>Overview (Javadoc - jroutine-android-reflect)</title>
<meta name="date" content="2017-02-10">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (Javadoc - jroutine-android-reflect)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">jroutine-android-reflect 7.0.0</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block"><a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a></div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/reflect/package-summary.html">com.github.dm.jrt.android.reflect</a></td>
<td class="colLast">
<div class="block">Core classes and interfaces related to reflection routine building and invocation, specific to
 the Android platform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/reflect/annotation/package-summary.html">com.github.dm.jrt.android.reflect.annotation</a></td>
<td class="colLast">
<div class="block">Android platform specific annotation definitions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/reflect/builder/package-summary.html">com.github.dm.jrt.android.reflect.builder</a></td>
<td class="colLast">
<div class="block">Android routine builder definitions.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/v11/reflect/package-summary.html">com.github.dm.jrt.android.v11.reflect</a></td>
<td class="colLast">
<div class="block">Object routine interfaces and implementations specific to the Android platform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/v4/reflect/package-summary.html">com.github.dm.jrt.android.v4.reflect</a></td>
<td class="colLast">
<div class="block">Object routine interfaces and implementations with support for the Android compatibility library.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block"><a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a>
<h1>Overview</h1>
<p>
    Android customization of asynchronous calling of object or class methods based on the <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/reflect" target="_blank">jroutine-reflect</a> library.
</p>
<p>
    This module provides classes enabling asynchronous invocations of object or class methods via reflection.<br>
    Methods are invoked inside dedicated Android Services and Loaders.
</p>
<h2>Main concepts</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-reflect/com/github/dm/jrt/android/reflect/ContextInvocationTarget.html">ContextInvocationTarget</a>
        <p>
            An invocation target represents the class or the instance whose methods are to be invoked asynchronously.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-reflect/com/github/dm/jrt/android/reflect/builder/LoaderReflectionRoutineBuilder.html">LoaderReflectionRoutineBuilder</a>
        <p>
            Each Loader reflection routine instance needs a Context invocation target and a specific configuration, so reflection routine builders provide a convenient way to set the required options.
            Object routine builders can be also used to build objects proxying the invocation target through an interface.
            By design builders are not synchronized since the same instance is not meant to be used from different threads.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-reflect/com/github/dm/jrt/android/reflect/builder/ServiceReflectionRoutineBuilder.html">ServiceReflectionRoutineBuilder</a>
        <p>
            Each Service reflection routine instance needs a Context invocation target and a specific configuration, so reflection routine builders provide a convenient way to set the required options.
            Object routine builders can be also used to build objects proxying the invocation target through an interface.
            By design builders are not synchronized since the same instance is not meant to be used from different threads.
        </p>
    </li>
</ul>
<h2>Main classes</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-reflect/com/github/dm/jrt/android/v11/reflect/JRoutineLoaderReflection.html">JRoutineLoaderReflection</a>
        <p>
            Utility class acting as a factory of Loader reflection routine builders.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-reflect/com/github/dm/jrt/android/v4/reflect/JRoutineLoaderReflectionCompat.html">JRoutineLoaderReflectionCompat</a>
        <p>
            Utility class acting as a factory of Loader reflection routine builders.<br>
            This class is specifically meant to employ the Android Support library for retro-compatibility.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-reflect/com/github/dm/jrt/android/reflect/JRoutineServiceReflection.html">JRoutineServiceReflection</a>
        <p>
            Utility class acting as a factory of Service reflection routine builders.
        </p>
    </li>
</ul>
<h2>Dependencies</h2>
<p>
    Below a full list of the included modules:
</p>
<ul>
    <li><a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/android-core" target="_blank">jroutine-android-core</a> &mdash; core routine and channel classes</li>
    <li><a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/core" target="_blank">jroutine-core</a> &mdash; core routine and channel classes</li>
    <li><a href="http://davide-maestroni.github.io/jroutine/javadoc/7.0.0/reflect" target="_blank">jroutine-reflect</a> &mdash; routines wrapping object and class methods</li>
</ul>
<h2>Usage examples</h2>
<p>
    The code below shows how it is possible to load an image from the network in a background thread, by letting the library automatically handle any change in the configuration.<br>
    Note that the very same examples can be re-written using JRoutineLoaderReflectionCompat and a FragmentActivity, or the JRoutineServiceReflection class, in order to make the processing happen in a Service instead of a Loader.
</p>
<b>Example 1:</b> via reflection.
<p>
    Note that this approach is fairly naive, since it lets the framework retain the instance of the downloaded bitmap.<br>
    A smarter implementation would involve the use of a dedicated cache.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            private static final String LOAD_BITMAP = "load_bitmap";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoaderReflection.on(loaderFrom(this))
                                        .with(instanceOf(BitmapLoader.class))
                                        .loaderConfiguration()
                                        .withCacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                                        .apply()
                                        .method(LOAD_BITMAP)
                                        .call(URI.create(IMAGE_URI))
                                        .bind(new TemplateChannelConsumer&lt;Bitmap&gt;() {

                                            &commat;Override
                                            public void onError(&commat;NotNull final RoutineException error) {
                                                final Throwable cause = error.getCause();
                                                Toast.makeText(MainTestActivity.this, (cause != null) ?
                                                        cause.getMessage() : "Cannot load image",
                                                        Toast.LENGTH_LONG).show();
                                            }

                                            &commat;Override
                                            public void onOutput(final Bitmap bitmap) {
                                                imageView.setImageBitmap(bitmap);
                                            }
                                        });
            }

            public static class BitmapLoader {

                &commat;Alias(LOAD_BITMAP)
                &commat;NotNull
                public Bitmap loadFromUri(&commat;NotNull final URI uri) throws IOException {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap == null) {
                            throw new IOException("failed to decode bitmap");
                        }

                        return bitmap;

                    } finally {
                        inputStream.close();
                    }
                }
            }
        }
    </code>
</pre>
<b>Example 2:</b> via proxy.
<p>
    The same result is obtained through the use of a proxy interface.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            private static final String LOAD_BITMAP = "load_bitmap";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoaderReflection.on(loaderFrom(this))
                                        .with(instanceOf(BitmapLoader.class))
                                        .buildProxy(BitmapLoaderItf.class)
                                        .loadFromUri(URI.create(IMAGE_URI))
                                        .bind(new TemplateChannelConsumer&lt;Bitmap&gt;() {

                                            &commat;Override
                                            public void onError(&commat;NotNull final RoutineException error) {
                                                final Throwable cause = error.getCause();
                                                Toast.makeText(MainTestActivity.this, (cause != null) ?
                                                        cause.getMessage() : "Cannot load image",
                                                        Toast.LENGTH_LONG).show();
                                            }

                                            &commat;Override
                                            public void onOutput(final Bitmap bitmap) {
                                                imageView.setImageBitmap(bitmap);
                                            }
                                        });
            }

            public interface BitmapLoaderItf {

                &commat;Alias(LOAD_BITMAP)
                &commat;CacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                &commat;AsyncOutput
                &commat;NotNull
                Channel&lt;?, Bitmap&gt; loadFromUri(&commat;NotNull URI uri);
            }

            public static class BitmapLoader {

                &commat;Alias(LOAD_BITMAP)
                &commat;NotNull
                public Bitmap loadFromUri(&commat;NotNull final URI uri) throws IOException {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap == null) {
                            throw new IOException("failed to decode bitmap");
                        }

                        return bitmap;

                    } finally {
                        inputStream.close();
                    }
                }
            }
        }
    </code>
</pre>
<b>Example 3:</b> via proxy with custom Context.
<p>
    It is possible to customize the creation of the wrapped object by using a Context wrapper as shown below.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            private static final String LOAD_BITMAP = "load_bitmap";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoaderReflection.on(loaderFrom(this, new MyContext(this)))
                                        .with(instanceOf(BitmapLoader.class))
                                        .buildProxy(BitmapLoaderItf.class)
                                        .loadFromUri(URI.create(IMAGE_URI))
                                        .bind(new TemplateChannelConsumer&lt;Bitmap&gt;() {

                                            &commat;Override
                                            public void onError(&commat;NotNull final RoutineException error) {
                                                final Throwable cause = error.getCause();
                                                Toast.makeText(MainTestActivity.this, (cause != null) ?
                                                        cause.getMessage() : "Cannot load image",
                                                        Toast.LENGTH_LONG).show();
                                            }

                                            &commat;Override
                                            public void onOutput(final Bitmap bitmap) {
                                                imageView.setImageBitmap(bitmap);
                                            }
                                        });
            }

            public interface BitmapLoaderItf {

                &commat;Alias(LOAD_BITMAP)
                &commat;CacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                &commat;AsyncOutput
                &commat;NotNull
                Channel&lt;?, Bitmap&gt; loadFromUri(&commat;NotNull URI uri);
            }

            public static class BitmapLoader {

                &commat;Alias(LOAD_BITMAP)
                &commat;NotNull
                public Bitmap loadFromUri(&commat;NotNull final URI uri) throws IOException {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap == null) {
                            throw new IOException("failed to decode bitmap");
                        }

                        return bitmap;

                    } finally {
                        inputStream.close();
                    }
                }
            }

            private static class MyContext extends FactoryContextWrapper {

                private final BitmapLoader mLoader;

                public MyContext(&commat;NotNull final Context base) {
                    super(base);
                    mLoader = new BitmapLoader();
                }

                &commat;Nullable
                public &lt;TYPE&gt; TYPE geInstance(&commat;NotNull final Class&lt;? extends TYPE&gt; type,
                        &commat;NotNull final Object... args) {
                    if (type == BitmapLoader.class) {
                        return type.cast(mLoader);
                    }

                    return null;
                }
            }
        }
    </code>
</pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
