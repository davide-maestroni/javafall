<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_77) on Tue Aug 09 17:13:16 CEST 2016 -->
<title>Overview (Javadoc - jroutine-androidcore)</title>
<meta name="date" content="2016-08-09">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (Javadoc - jroutine-androidcore)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">jroutine-androidcore 6.0.0</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block"><a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a></div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/package-summary.html">com.github.dm.jrt.android.core</a></td>
<td class="colLast">
<div class="block">Core routine classes and interfaces specific to the Android platform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/builder/package-summary.html">com.github.dm.jrt.android.core.builder</a></td>
<td class="colLast">
<div class="block">Android routine builder definitions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/config/package-summary.html">com.github.dm.jrt.android.core.config</a></td>
<td class="colLast">
<div class="block">Classes storing Android routine and channel configurations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/invocation/package-summary.html">com.github.dm.jrt.android.core.invocation</a></td>
<td class="colLast">
<div class="block">Invocation classes and interfaces specific to the Android platform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/log/package-summary.html">com.github.dm.jrt.android.core.log</a></td>
<td class="colLast">
<div class="block">Log classes specific to the Android platform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/routine/package-summary.html">com.github.dm.jrt.android.core.routine</a></td>
<td class="colLast">
<div class="block">Routine interfaces specific to the Android platform.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/runner/package-summary.html">com.github.dm.jrt.android.core.runner</a></td>
<td class="colLast">
<div class="block">Runner related classes and definitions specific to the Android platform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/core/service/package-summary.html">com.github.dm.jrt.android.core.service</a></td>
<td class="colLast">
<div class="block">Android service classes implementation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/v11/core/package-summary.html">com.github.dm.jrt.android.v11.core</a></td>
<td class="colLast">
<div class="block">Loader based routine interfaces and implementations specific to the Android platform.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/android/v4/core/package-summary.html">com.github.dm.jrt.android.v4.core</a></td>
<td class="colLast">
<div class="block">Loader based routine interfaces and implementations with support for Android compatibility
 library.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block"><a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a>
<h1>Overview</h1>
<p>
    Android platform customization of the <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/core" target="_blank">JRoutine-Core</a> library.
</p>
<h2>Main concepts</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/invocation/ContextInvocation.html">ContextInvocation</a>
        <p>
            Interface representing an Android Context aware <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/core/com/github/dm/jrt/core/invocation/Invocation.html">Invocation</a>.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/invocation/ContextInvocationFactory.html">ContextInvocationFactory</a>
        <p>
            A factory is needed to dynamically instantiate new context invocation objects. In fact, the same routine can be invoked several times on different threads, and, each time, an invocation instance will be required to process the input data.
            Invocation factories might be used to identify the invocation type, for this reason the constructor parameters (which should always be immutable or effectively so) are required to be passed to the base class.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/routine/LoaderRoutine.html">LoaderRoutine</a>
        <p>
            A loader routine object enables the execution of invocations inside a Loader instance.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/builder/LoaderRoutineBuilder.html">LoaderRoutineBuilder</a>
        <p>
            Each loader routine instance needs an invocation factory and a specific configuration, so routine builders provide a convenient way to set the required options.
            The invocation factory and the inputs are automatically employed compute the specific Loader ID.
            By design builders are not synchronized since the same instance is not meant to be used from different threads.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/invocation/TargetInvocationFactory.html">TargetInvocationFactory</a>
        <p>
            A target invocation factory is meant to describe a factory of invocations to be used by an Android service to build and run new invocations.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/builder/ServiceRoutineBuilder.html">ServiceRoutineBuilder</a>
        <p>
            Routine instances running in a dedicated service can be built through specifically configured routine builder.
            Each service routine instance needs a target invocation factory and a specific configuration, so routine builders provide a convenient way to set the required options.
            By design builders are not synchronized since the same instance is not meant to be used from different threads.
        </p>
    </li>
</ul>
<h2>Main classes</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/log/AndroidLogs.html">AndroidLogs</a>
        <p>
            Utility class acting as a factory of log instances.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/runner/AndroidRunners.html">AndroidRunners</a>
        <p>
            Utility class acting as a factory of runner instances.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/v11/core/LoaderContext.html">LoaderContext</a>
        <p>
            A loader context instance is meant to describe an Android Context to be used with Loader instances.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/v11/core/JRoutineLoader.html">JRoutineLoader</a>
        <p>
            Utility class acting as a factory of loader routine and channel builders.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/v4/core/LoaderContextCompat.html">LoaderContextCompat</a>
        <p>
            A loader context instance is meant to describe an Android Context to be used with Loader instances.
            This class is specifically meant to employ the Android Support library for retro-compatibility.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/v4/core/JRoutineLoaderCompat.html">JRoutineLoaderCompat</a>
        <p>
            Utility class acting as a factory of loader routine and channel builders.
            This class is specifically meant to employ the Android Support library for retro-compatibility.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/ServiceContext.html">ServiceContext</a>
        <p>
            A service context instance is meant to describe an Android Context to be used with Service instances.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/androidcore/com/github/dm/jrt/android/core/JRoutineService.html">JRoutineService</a>
        <p>
            Utility class acting as a factory of service routine builders.
        </p>
    </li>
</ul>
<h2>Usage examples</h2>
<p>
    The code below shows how it is possible to load an image from the network in a background thread, by letting the library automatically handle any change in the configuration.<br>
    Note that the very same examples can be re-written using JRoutineLoaderCompat class and a FragmentActivity.
</p>
<b>Example 1:</b> simple approach.
<p>
    Note that this approach is fairly naive, since it lets the framework retain the instance of the downloaded bitmap.<br>
    A smarter implementation would involve the use of a dedicated cache.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoader.on(loaderFrom(this))
                              .with(factoryOf(LoadBitmap.class))
                              .loaderConfiguration()
                              .withCacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                              .configured()
                              .asyncCall(URI.create(IMAGE_URI))
                              .bind(new TemplateChannelConsumer&lt;Bitmap&gt;() {

                                  &commat;Override
                                  public void onError(&commat;NotNull final RoutineException error) {
                                      final Throwable cause = error.getCause();
                                      Toast.makeText(MainTestActivity.this, (cause != null) ?
                                              cause.getMessage() : "Cannot load image",
                                              Toast.LENGTH_LONG).show();
                                  }

                                  &commat;Override
                                  public void onOutput(final Bitmap bitmap) {
                                      imageView.setImageBitmap(bitmap);
                                  }
                              });
            }

            public static class LoadBitmap extends TemplateContextInvocation&lt;URI, Bitmap&gt; {

                &commat;Override
                public void onInput(final URI uri, &commat;NotNull final Channel&lt;Bitmap, ?&gt; result) throws
                        Exception {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap != null) {
                            result.pass(bitmap);

                        } else {
                            result.abort();
                        }

                    } finally {
                        inputStream.close();
                    }
                }
            }
        }
    </code>
</pre>
<b>Example 2:</b> load in a service.
<p>
    The above example can be slightly modified to make the real loading happen in a dedicated service.<br>
    Note that the service might even run in a separate process, since the Bitmap class implements the Parcelable interface. However, keep in mind that, depending on the specific image size, the amount of serialized data might exceed the parcel limits.
</p>
<pre>
    <code>
        public class MainActivity extends Activity {

            private static final String IMAGE_URI = "http://...";

            &commat;Override
            protected void onCreate(final Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);
                final ImageView imageView = (ImageView) findViewById(R.id.image);
                JRoutineLoader.on(loaderFrom(this))
                              .with(factoryOf(LoadBitmapFromService.class))
                              .loaderConfiguration()
                              .withCacheStrategy(CacheStrategyType.CACHE_IF_SUCCESS)
                              .configured()
                              .asyncCall(URI.create(IMAGE_URI))
                              .bind(new TemplateChannelConsumer&lt;Bitmap&gt;() {

                                  &commat;Override
                                  public void onError(&commat;NotNull final RoutineException error) {
                                      final Throwable cause = error.getCause();
                                      Toast.makeText(MainTestActivity.this, (cause != null) ?
                                              cause.getMessage() : "Cannot load image",
                                              Toast.LENGTH_LONG).show();
                                  }

                                  &commat;Override
                                  public void onOutput(final Bitmap bitmap) {
                                      imageView.setImageBitmap(bitmap);
                                  }
                              });
            }

            public static class LoadBitmap extends TemplateContextInvocation&lt;URI, Bitmap&gt; {

                &commat;Override
                public void onInput(final URI uri, &commat;NotNull final Channel&lt;Bitmap, ?&gt; result) throws
                        Exception {
                    final URLConnection urlConnection = uri.toURL().openConnection();
                    final InputStream inputStream = urlConnection.getInputStream();
                    try {
                        final Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                        if (bitmap != null) {
                            result.pass(bitmap);

                        } else {
                            result.abort();
                        }

                    } finally {
                       inputStream.close();
                    }
                }
            }

            public static class LoadBitmapFromService extends TemplateContextInvocation&lt;URI, Bitmap&gt; {

                private Routine&lt;URI, Bitmap&gt; mRoutine;

                &commat;Override
                public void onContext(&commat;NotNull final Context context) {
                    super.onContext(context);
                    mRoutine = JRoutineService.on(serviceFrom(context))
                                              .with(TargetInvocationFactory.factoryOf(LoadBitmap.class))
                                              .buildRoutine();
                }

                &commat;Override
                public void onInput(final URI uri, &commat;NotNull final Channel&lt;Bitmap, ?&gt; result) {
                    result.pass(mRoutine.asyncCall(uri));
                }
            }
        }
    </code>
</pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
