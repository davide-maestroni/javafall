<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_77) on Fri Oct 21 23:42:14 CEST 2016 -->
<title>Overview (Javadoc - jroutine-object)</title>
<meta name="date" content="2016-10-21">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (Javadoc - jroutine-object)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">jroutine-object 6.0.0</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block"><a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a></div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/object/package-summary.html">com.github.dm.jrt.object</a></td>
<td class="colLast">
<div class="block">Core classes and interfaces related to object routine building and invocation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/object/annotation/package-summary.html">com.github.dm.jrt.object.annotation</a></td>
<td class="colLast">
<div class="block">Definition of annotations used to configure proxy routines.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/object/builder/package-summary.html">com.github.dm.jrt.object.builder</a></td>
<td class="colLast">
<div class="block">Classes and interfaces related to object routine builders.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/github/dm/jrt/object/common/package-summary.html">com.github.dm.jrt.object.common</a></td>
<td class="colLast">
<div class="block">Common classes and interfaces.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/github/dm/jrt/object/config/package-summary.html">com.github.dm.jrt.object.config</a></td>
<td class="colLast">
<div class="block">Classes storing proxy routine configurations.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block"><a href="https://github.com/davide-maestroni/jroutine" target="_blank">Parallel programming on the go.</a>
<h1>Overview</h1>
<p>
    Asynchronous calling of object or class methods based on the <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/core" target="_blank">jroutine-core</a> library.
</p>
<p>
    This module provides classes enabling asynchronous invocations of object or class methods via reflection.
</p>
<h2>Main concepts</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/object/com/github/dm/jrt/object/InvocationTarget.html">InvocationTarget</a>
        <p>
            An invocation target represents the class or the instance whose methods are to be invoked asynchronously.
        </p>
    </li>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/object/com/github/dm/jrt/object/builder/ObjectRoutineBuilder.html">ObjectRoutineBuilder</a>
        <p>
            Each object routine instance needs an invocation target and a specific configuration, so object routine builders provide a convenient way to set the required options.
            Object routine builders can be also used to build objects proxying the invocation target through an interface.
            By design builders are not synchronized since the same instance is not meant to be used from different threads.
        </p>
    </li>
</ul>
<h2>Main classes</h2>
<ul>
    <li>
        <a href="http://davide-maestroni.github.io/jroutine/javadoc/6/object/com/github/dm/jrt/object/JRoutineObject.html">JRoutineObject</a>
        <p>
            Utility class acting as a factory of object routine builders.
        </p>
    </li>
</ul>
<h2>Dependencies</h2>
<p>
    Below a full list of the included modules:
</p>
<ul>
    <li><a href="http://davide-maestroni.github.io/jroutine/javadoc/6/core" target="_blank">jroutine-core</a> &mdash; core routine and channel classes</li>
</ul>
<h2>Usage examples</h2>
<p>
    The code below shows how it is possible to implement the computation of the root mean square of some input data, by distributing it in a number of background threads.
</p>
<b>Example 1:</b> via reflection.
<p>
    This approach allows the asynchronous invocation of an object methods by creating routines which wrap the methods to call.<br>
    In this case, the mean computation must actually wait for all the input data to be available before being invoked. Thus, it cannot really happen in a parallel way.
</p>
<pre>
    <code>
        public class Main {

            private static final String MEAN = "mean";

            private static final String PARSE = "parse";

            private static final String SQUARE = "square";

            public static void main(final String[] args) {
                final ObjectRoutineBuilder builder = JRoutineObject.with(classOfType(Main.class))
                                                                   .applyObjectConfiguration()
                                                                   .withSharedFields()
                                                                   .configured()
                                                                   .applyInvocationConfiguration()
                                                                   .withOutputTimeout(seconds(3))
                                                                   .configured();
                final Routine&lt;String, Integer&gt; parseRoutine = builder.method(PARSE);
                final Routine&lt;Integer, Integer&gt; squareRoutine = builder.method(SQUARE);
                final Routine&lt;List&lt;Integer&gt;, Double&gt; meanRoutine = builder.method(MEAN);
                final Double rms = meanRoutine.call(
                        squareRoutine.callParallel(parseRoutine.callParallel(args)).all()).next();
                System.out.println(rms);
                System.exit(0);
            }

            &commat;Alias(PARSE)
            private static int parseArg(final String arg) {
                return Integer.parseInt(arg);
            }

            &commat;Alias(SQUARE)
            private static int square(final int value) {
                return value * value;
            }

            &commat;Alias(MEAN)
            private static double squareRootMean(final List&lt;Integer&gt; values) {
                if (values.isEmpty()) {
                    return 0d;
                }

                int sum = 0;
                for (final int value : values) {
                    sum += value;
                }

                return Math.sqrt((double) sum / values.size());
            }
        }
    </code>
</pre>
<b>Example 2:</b> via proxy.
<p>
    Using a proxy object is just a convenient way to wrap several methods at once.<br>
    Note that the same annotations of the previous example could have been used to bind the methods with the proxy interface.
</p>
<pre>
    <code>
        public class Main {

            public static void main(final String[] args) {
                final Main main = new Main();
                final AsyncMain proxy = JRoutineObject.with(instance(main))
                                                      .applyObjectConfiguration()
                                                      .withSharedFields()
                                                      .configured()
                                                      .applyInvocationConfiguration()
                                                      .withOutputTimeout(seconds(3))
                                                      .configured()
                                                      .buildProxy(AsyncMain.class);
                final double rms = proxy.squareRootMean(proxy.square(proxy.parseArg(JRoutineCore.io().of(args))));
                System.out.println(rms);
                System.exit(0);
            }

            private int parseArg(final String arg) {
                return Integer.parseInt(arg);
            }

            private int square(final int value) {
                return value * value;
            }

            private double squareRootMean(final List&lt;Integer&gt; values) {
                if (values.isEmpty()) {
                    return 0d;
                }

                int sum = 0;
                for (final int value : values) {
                    sum += value;
                }

                return Math.sqrt((double) sum / values.size());
            }

            private interface AsyncMain {

                &commat;Invoke(InvocationMode.PARALLEL)
                &commat;AsyncOutput
                Channel&lt;?, Integer&gt; parseArg(&commat;AsyncInput(String.class) Channel&lt;?, String&gt; args);

                &commat;Invoke(InvocationMode.PARALLEL)
                &commat;AsyncOutput
                Channel&lt;?, Integer&gt; square(&commat;AsyncInput(int.class) Channel&lt;?, Integer&gt; value);

                double squareRootMean(
                        &commat;AsyncInput(value = List.class, mode = InputMode.COLLECTION) Channel&lt;?, Integer&gt; values);
            }
        }
    </code>
</pre></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
